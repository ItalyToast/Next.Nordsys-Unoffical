use crate::parse::{self, Class, Field};

pub fn gen_rust_from_next_js() {
    let classes = parse::parse_next_js();

    let mut result = String::new();

    result.push_str("/* ");
    result.push_str(&read_license());
    result.push_str(" */\r\n");
    result.push_str("\r\n");
    result.push_str("// This file is generated by the project found in gen/ \r\n");
    result.push_str("\r\n");
    result.push_str("use serde::{Serialize, Deserialize};\r\n");
    result.push_str("\r\n");
    result.push_str("pub trait TableTrait {\r\n");
    result.push_str("    fn name() -> &'static str;\r\n");
    result.push_str("}\r\n");
    result.push_str("\r\n");

    result.push_str("// Available tables:\r\n");
    for class in &classes {
        result.push_str(&format!("// -{}Store\r\n", &class.class_name));
    }

    for class in &classes {
        result.push_str(&gen_class(class));
    }

    std::fs::write("next.js.rs", result).unwrap();
}

fn gen_class(class : &Class) -> String {
    let mut class_res = String::new();

    class_res.push_str("/*\r\n");
    class_res.push_str(&class.class);
    class_res.push_str("*/\r\n");

    class_res.push_str("#[allow(non_snake_case)]\r\n");
    class_res.push_str("#[derive(Serialize, Deserialize, Clone)]\r\n");
    class_res.push_str(&format!("pub struct {}Store {{\r\n", &class.class_name));

    for field in &class.fields {
        class_res.push_str(&gen_field(&field));
    }

    class_res.push_str("}\r\n\r\n");

    // Add trait impl
    class_res.push_str(&format!("impl TableTrait for {}Store {{ ", &class.class_name));
    class_res.push_str(&format!("fn name() -> &'static str {{ \"{}Store\" }}", &class.class_name));
    class_res.push_str("}");

    class_res
}

fn gen_field(field : &Field) -> String {
    let mut text = String::new();
    if !field.always_present {
        text.push_str(&format!("    #[serde(default)]\r\n"));
    }
    match field.nullable {
        true => {
            text.push_str(&format!("    pub {} : Option<String>, //{}\r\n", field.name, field.datatype));
        },
        false => {
            text.push_str(&format!("    pub {} : String, //{}\r\n", field.name, field.datatype));
        },
    };

    text
}

fn read_license() -> String {
    let content = std::fs::read("LICENSE").unwrap();
    String::from_utf8(content).unwrap()
}
