use crate::parse::{self, Class, Field};

pub fn gen_dart_from_next_js() {
    let classes = parse::parse_next_js();

    let mut result = String::new();

    result.push_str("/* ");
    result.push_str(&read_license());
    result.push_str(" */\r\n");
    result.push_str("\r\n");
    result.push_str("// This file is generated by the project found in gen/ \r\n");
    result.push_str("\r\n");
    
    result.push_str("// Available tables:\r\n");
    for class in &classes {
        result.push_str(&format!("// -{}Store\r\n", &class.class_name));
    }
    result.push_str("\r\n");
    result.push_str("// ignore_for_file: non_constant_identifier_names");
    result.push_str("\r\n");
    result.push_str("\r\n");

    for class in &classes {
        result.push_str(&gen_class(class));
    }

    std::fs::write("next.js.dart", result).unwrap();
}

fn gen_class(class : &Class) -> String {
    let mut class_res = String::new();

    class_res.push_str("/*\r\n");
    class_res.push_str(&class.class);
    class_res.push_str("*/\r\n");
    class_res.push_str("\r\n");

    class_res.push_str(&format!("class {}Store {{\r\n", &class.class_name));
    class_res.push_str(&format!("  static String name = '{}Store';\r\n", &class.class_name));
    class_res.push_str("\r\n");

    for field in &class.fields {
        class_res.push_str(&gen_field(&field));
    }

    //gen constructor
    class_res.push_str("\r\n");
    class_res.push_str(&format!("  {}Store(\r\n", &class.class_name));
    for field in &class.fields {
        class_res.push_str(&format!("    this.{},\r\n", &field.name));
    }
    class_res.push_str("  );\r\n");


    //gen fromJson
    class_res.push_str("\r\n");
    class_res.push_str(&format!("  {}Store.fromJson(Map<String, dynamic> json) : \r\n", &class.class_name));
    let field_strings : Vec<String> = class.fields.iter()
        .map(|field| format!("    {} = json['{}'] ?? ''", &field.name, &field.name))
        .collect();

    class_res.push_str(&field_strings.join(",\r\n"));
    class_res.push_str(";\r\n");

    //gen toJson
    class_res.push_str("\r\n");
    class_res.push_str(&format!("  Map<String, dynamic> toJson() => {{ \r\n"));
    for field in &class.fields {
        class_res.push_str(&format!("    '{}' : {},\r\n", &field.name, &field.name));
    }
    class_res.push_str("  };\r\n");

    class_res.push_str("}\r\n\r\n");
    class_res.push_str("\r\n");

    class_res
}

fn gen_field(field : &Field) -> String {
    let mut text = String::new();
    match field.nullable {
        true => {
            text.push_str(&format!("    final String? {}; //{}\r\n", field.name, field.datatype));
        },
        false => {
            text.push_str(&format!("    final String {}; //{}\r\n", field.name, field.datatype));
        },
    };

    text
}

fn read_license() -> String {
    let content = std::fs::read("LICENSE").unwrap();
    String::from_utf8(content).unwrap()
}