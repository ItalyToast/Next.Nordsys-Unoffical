use std::{string, str::FromStr, collections::HashMap};

use serde::{Deserialize, Serialize};
use serde_json::Value;
use regex::{RegexBuilder};

#[derive(Serialize, Deserialize)]
struct ApiResponse<T> {
    pub success : bool,
    pub rows : Option<Vec<T>>,
}

fn main() {
    gen_from_next_js();
    /*
    let args: Vec<String> = env::args().collect();

    if args.len() != 1 {
        println!("Please provide a name");
    }

    gen_from_json_file(args.first().unwrap());
    */
}


pub fn gen_from_json_file(name : &str) {
    let content = std::fs::read("json.txt").unwrap();
    let json = String::from_utf8(content).unwrap();
    gen_from_json(name, &json);
}

fn gen_from_json(name : &str, json : &str) {
    match serde_json::from_str::<ApiResponse<Value>>(json) {
        Ok(json) => {
            match json.rows {
                Some(res) => {
                    if let Some(s) = res.first() {
                        let s = gen_struct(name, s);
                        let mut path = String::new();
                        path.push_str("gen/");
                        path.push_str(name);
                        path.push_str(".txt");
                        std::fs::write(path, s).unwrap();
                    }
                },
                None => println!("No rows returned"),
            }
        },
        Err(err) => {
            println!("[{}]{:?}", name, err);
        },
    }
}

fn gen_struct(name : &str, json : &Value) -> String {
    let mut code = String::new();
    code.push_str("#[allow(non_snake_case)]\r\n");
    code.push_str("#[derive(Serialize, Deserialize, Clone)]\r\n");
    code.push_str("pub struct ");
    code.push_str(name);
    code.push_str(" {\r\n");

    for (k, _v) in json.as_object().unwrap() {
        code.push_str("    pub ");
        code.push_str(k);
        code.push_str(" : String,\r\n");
    }

    code.push_str("}");
    code
}

fn gen_from_next_js() {
    /*
    Ext.define("MEM.model.AccountChart", {
        extend: MEM.model.Base,
        config: {
            fields: [
            { name: "AccountNo", type: "string", meType: "meShortText", max: 5 },
            {
                name: "Account",
                type: "string",
                meType: "meShortText",
                max: 5,
                convert: function (b, a) {
                return a.get("AccountNo") + " " + a.get("Description");
                },
            },
            { name: "Description", type: "string", meType: "meMediumText", max: 50 },
            { name: "Cost", type: "bool", meType: "meBool" },
            { name: "Work", type: "bool", meType: "meBool" },
            { name: "Material", type: "bool", meType: "meBool" },
            { name: "VatCode", type: "string", meType: "meShortText", max: 10 },
            {
                name: "ComplementAccount",
                type: "string",
                meType: "meShortText",
                max: 5,
            },
            { name: "VatDuty", type: "bool", meType: "meBool" },
            { name: "InvoiceOnImport", type: "bool", meType: "meBool" },
            { name: "RotShare", type: "int", meType: "meInt" },
            ],
        },
        });
        Ext.define("MEM.store.MyAccountChartStore", {
        extend: MEM.ux.data.MyBaseStore,
        config: {
            model: "MEM.model.AccountChart",
            storeId: "MyAccountChartStore",
            autoLoad: !1,
            autoSync: !1,
            remoteFilter: !1,
            sortOnLoad: !0,
            sorters: [{ property: "AccountNo", directon: "ASC" }],
            proxy: { type: "myproxy", url: Me.STORE_URL + "AccountChartStore" },
        },
        });
        */

    let class_regex = RegexBuilder::new("Ext\\.define\\(\"MEM\\.model\\.([a-zA-Z]+)\".*?fields(.*?)]")
        .dot_matches_new_line(true)
        .build().unwrap();
    let fields_regex = RegexBuilder::new("\\{([ \r\n]*)name: \"(\\w*)\",([ \r\n]*) type: \"(\\w*)\".*?\\}")
        .dot_matches_new_line(true)
        .build().unwrap();

    let data = std::fs::read_to_string("next.js").unwrap();

    let mut result = String::new();
    result.push_str("use serde::{Serialize, Deserialize};");
    result.push_str("use crate::tables_trait::TableTrait;");
    result.push_str("\r\n");
    result.push_str("// This file is generated by the project found in gen/ \r\n");
    result.push_str("\r\n");
    
    for class_cap in class_regex.captures_iter(&data) {
        let mut class_res = String::new();
        let class = class_cap.get(0).unwrap().as_str().to_string();
        let class_name = class_cap.get(1).unwrap().as_str().to_string();

        if class_name == "Base" {
            continue;
        }

        class_res.push_str("/*\r\n");
        class_res.push_str(&class);
        class_res.push_str("*/\r\n");

        class_res.push_str("#[allow(non_snake_case)]\r\n");
        class_res.push_str("#[derive(Serialize, Deserialize, Clone)]\r\n");
        class_res.push_str(&format!("pub struct {}Store {{\r\n", class_name));
        
        println!("class {}", &class);
        let mut fields:  HashMap<String, String>= HashMap::new();
        fields.insert("Id".to_string(),"int".to_string());
        fields.insert("Created".to_string(),"date".to_string());
        fields.insert("CreatedId".to_string(),"string".to_string());
        fields.insert("Changed".to_string(),"date".to_string());
        fields.insert("ChangedId".to_string(),"string".to_string());
        fields.insert("Disabled".to_string(),"boolean".to_string());

        for field_cap in fields_regex.captures_iter(&class)  {
            let field_name = field_cap.get(2).unwrap().as_str().to_string();
            let field_type = field_cap.get(4).unwrap().as_str().to_string();
            println!("field {} : {}", &field_name, &field_type);
            fields.insert(field_name, field_type);
        }
        
        for (name, t) in fields {
            class_res.push_str(&format!("    pub {} : String, //{}\r\n", name, t));
        }

        class_res.push_str("}\r\n\r\n");

        // Add trait impl
        class_res.push_str(&format!("impl TableTrait for {}Store {{ ", class_name));
        class_res.push_str(&format!("fn name() -> &'static str {{ \"{}Store\" }}", class_name));
        class_res.push_str(" }");

        println!("{}", &class_res);
        result.push_str(&class_res);
    }

    std::fs::write("next.js.txt", result).unwrap();
}
